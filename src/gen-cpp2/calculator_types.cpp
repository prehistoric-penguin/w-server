/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "calculator_types.h"

#include "calculator_types.tcc"

#include <algorithm>

namespace calculator {

Operation _kOperationValues[] = {
  Operation::ADD,
  Operation::SUBTRACT,
  Operation::MULTIPLY,
  Operation::DIVIDE
};

const char* _kOperationNames[] = {
  "ADD",
  "SUBTRACT",
  "MULTIPLY",
  "DIVIDE"
};

const std::map<Operation, const char*> _Operation_VALUES_TO_NAMES(apache::thrift::TEnumIterator<Operation>(4, _kOperationValues, _kOperationNames), apache::thrift::TEnumIterator<Operation>(-1, nullptr, nullptr));
const std::map<const char*, Operation, apache::thrift::ltstr> _Operation_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<Operation>(4, _kOperationValues, _kOperationNames), apache::thrift::TEnumInverseIterator<Operation>(-1, nullptr, nullptr));

} // calculator
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::calculator::Operation>::findName( ::calculator::Operation value) {
  return findName( ::calculator::_Operation_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::calculator::Operation>::findValue(const char* name,  ::calculator::Operation* outValue) {
  return findValue( ::calculator::_Operation_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace calculator {

void Work::__clear() {
  num1 = 0;
  num2 = 0;
  op =  ::calculator::Operation();
  comment = std::string();
  __isset.__clear();
}

bool Work::operator==(const Work& rhs) const {
  if (!((num1 == rhs.num1))) {
    return false;
  }
  if (!((num2 == rhs.num2))) {
    return false;
  }
  if (!((op == rhs.op))) {
    return false;
  }
  if (__isset.comment != rhs.__isset.comment) {
    return false;
  }
  else if (__isset.comment && !((comment == rhs.comment))) {
    return false;
  }
  return true;
}

void swap(Work& a, Work& b) {
  using ::std::swap;
  swap(a.num1, b.num1);
  swap(a.num2, b.num2);
  swap(a.op, b.op);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

} // calculator
namespace apache { namespace thrift {

}} // apache::thrift
namespace calculator {

void InvalidOperation::__clear() {
  op =  ::calculator::Operation();
  why = std::string();
  __isset.__clear();
}

bool InvalidOperation::operator==(const InvalidOperation& rhs) const {
  if (!((op == rhs.op))) {
    return false;
  }
  if (!((why == rhs.why))) {
    return false;
  }
  return true;
}

void swap(InvalidOperation& a, InvalidOperation& b) {
  using ::std::swap;
  swap(a.op, b.op);
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

} // calculator
namespace apache { namespace thrift {

}} // apache::thrift
namespace calculator {

} // calculator